📝 비동기 함수 동작원리

코드 : 
```js
const getItems = async () => {
  const response = await fetch(
    'https://panda-market-api.vercel.app/products?page=1&pageSize=1'
  );
  const body = await response.json();
  return body;
};

const consoleResult = async () => {
  const result = await getItems();
  console.log(result);
};

consoleResult();
console.log('Finished!');
```

전역 컨텍스트가 Call Stack에 Push 된 후 실행

consoleResult() 함수가 Call Stack에 Push된 후 실행

consoleResult 함수는 async로 실행되기 때문에 실행되자마자 return 값이 Promise 객체가 됨

const result = await getItems(); 실행
getItems()함수가 Call Stack에 Push된 후 실행
이 때, getItems함수는 await을 이용해 실행되었기 때문에 then 콜백함수를 내부적으로 생성하고 consoleResult의 렉시컬 변수환경을 기억함.
then((resolvedValue)=>{const result = resolvedValue});

const response = await fetch(...) 실행
fetch()함수가 Call Stack에 Push된 후 실행
이 때, fetch함수는 await을 이용해 실행되었기 때문에 then 콜백함수를 내부적으로 생성하고 getItems의 렉시컬 변수환경을 기억함.
then((resolvedValue)=>{const response = resolvedValue});

fetch의 응답이 올때까지 getItems함수의 실행을 일시 정지
response(Promise 객체)의 then 콜백함수는 비동기 관리 시스템에 저장되어 Micro Task Queue에 등록을 예약함
getItems함수를 콜 스택에서 pop

getItems의 응답이 올때까지 consoleResult함수의 실행을 일시 정지
result(Promise 객체)의 then 콜백함수는 비동기 관리 시스템에 저장되어 Micro Task Queue에 등록을 예약함
consoleResult함수를 콜 스택에서 pop

console.log('Finished'); 실행

전역 컨텍스트의 구문이 모두 실행되었으므로 구문 종료 후 Pop

fetch의 응답이 도착하면 비동기 관리 시스템에 저장되어있는 response(Promise 객체)의 then 콜백함수가 Micro Task Queue로 Push

Call Stack이 비워졌기 때문에 Micro Task Queue에 저장되어있는 then 콜백함수가 이벤트 루프에 의해 Call Stack에 Push

then 콜백함수 실행되고, 콜백함수가 기억하는 렉시컬 환경이 Call Stack에 Push
then((resolvedValue)=>{const response = resolvedValue});

const body = await response.json(); 실행
response.json() 함수가 Call Stack에 Push된 후 실행
이 때, response.json() 함수는 await을 이용해 실행되었기 때문에 then 콜백함수를 내부적으로 생성하고 getItems의 렉시컬 변수환경을 기억함.
then((resolvedValue)=>{const body = resolvedValue});

response.json()의 응답이 올 때까지 getItems함수의 실행을 일시 정지
body(Promise 객체)의 then 콜백함수는 비동기 관리 시스템에 저장되어 Micro Task Queue에 등록을 예약함
getItems함수를 콜 스택에서 pop

