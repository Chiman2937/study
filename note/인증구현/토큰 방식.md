# 토큰 방식을 이용한 인증 시스템 구현

## 작업 환경

백엔드 API가 CORS를 허용하고 토큰을 Response Body로 반환하는 환경일 때 클라이언트에서 보안을 어느 수준까지 확보할 수 있는지 테스트 해보고자 했다.

<br></br>

## 문제 상황

기존 토큰 기반 인증 시스템에서 발생할 수 있는 보안 위협들을 검토했다.

<br></br>

### 주요 보안 위협
1. **XSS(Cross-Site Scripting)**: 악성 스크립트를 통한 토큰 탈취
2. **CSRF(Cross-Site Request Forgery)**: 인증된 사용자의 의도하지 않은 요청 실행
3. **토큰 노출**: 개발자 도구나 스크립트를 통한 토큰 접근

Storage 저장 방식으로는 이러한 위협에 취약하다는 문제가 있었다.

<br></br>

## 해결 방안 검토

### 1차 검토: HttpOnly Cookie 도입
XSS 공격을 방지하기 위해 스크립트로 접근 불가능한 HttpOnly Cookie를 사용하기로 결정했다.

```typescript
export const HTTPONLY_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax' as const,
  path: '/',
  maxAge: 60 * 60 * 6, // 6시간
};
```

<br></br>

### 2차 검토: 클라이언트 토큰 접근 문제
HttpOnly Cookie 사용 시 클라이언트에서 토큰에 접근할 수 없어 API 요청 시 Authorization 헤더를 설정할 수 없는 문제가 발생했다.

#### 검토한 해결책들

**1. Next.js API를 프록시로 활용**
- 모든 API 요청을 Next.js API를 경유하도록 구성
- ❌ 모든 HTTP 메서드와 상태 코드에 대한 처리 필요
- ❌ 웹 서버 비용 증가
- ❌ 네트워크 탭에서 실제 API 요청 확인 불가

**2. 토큰 접근 전용 Next.js API 제작**
```typescript
// app/api/token/route.ts
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function GET() {
  const cookieStore = await cookies();
  const token = cookieStore.get('accessToken')?.value;
  
  return NextResponse.json({ token });
}
```
- ❌ HttpOnly의 보안 의미 퇴색
- ❌ 토큰 접근 엔드포인트 노출

**3. 토큰 발급 시 요청 헤더에 미리 저장**
```typescript
// 로그인 응답에서 토큰 추출 후 axios 기본 헤더에 설정
const loginResponse = await axios.post('/api/auth/login', credentials);
const { accessToken } = loginResponse.data;

// axios 인스턴스의 기본 헤더에 토큰 설정
baseAPI.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;

// 이후 모든 요청에 자동으로 토큰이 포함됨
const userProfile = await baseAPI.get('/api/user/profile');
```

- ❌ Axios 인터셉터 로직과 분리 필요
- ❌ 추적성 저하 (토큰 설정과 요청 로직이 분산)

**4. Server Action 활용 (최종 선택)**
- ✅ 엔드포인트 노출 없음
- ✅ 인터셉터 로직 내에서 해결 가능
- ✅ Next.js 기본 CSRF 방지 지원

<br></br>

> Next.js의 서버 액션 CSRF 방지 기능

- 자동 CSRF 토큰: Next.js가 자동으로 생성하고 검증하는 토큰 시스템
- 쿠키-폼 데이터 검증: 요청 시마다 쿠키와 폼 데이터의 토큰을 비교
- Same-Origin 정책: 외부 도메인에서의 무단 호출 차단
- 서버 지시문 제한: 'use server'가 있는 함수만 실행 가능

<br></br>

## 최종 해결책

### 하이브리드 API 통신 구조
보안과 성능의 균형을 위해 API 특성에 따라 다른 통신 방식을 적용했다.

```
인증 관련 API: authAPI <=> Next.js API <=> Backend
일반 API:      baseAPI <=> Backend (직접 통신)
```

<br></br>

### 인증 API 프록시 구현
- 로그인
```ts
const BaseURL = process.env.NEXT_PUBLIC_API_BASE_URL;

export const POST = async (req: NextRequest) => {
  try {
    const body = await req.json();
    const response = await axios.post<AuthResponse>(`${BaseURL}/auth/signIn`, body);
    const { accessToken, user } = response.data;

    const res = NextResponse.json(user, { status: 200 });
    res.cookies.set('accessToken', accessToken, HTTPONLY_COOKIE_OPTIONS);
    res.cookies.set('userId', String(user.id), DEFAULT_COOKIE_OPTIONS);
    return res;
  } catch (err) {
    if (axios.isAxiosError(err) && err.response) {
      return NextResponse.json(err.response.data, { status: err.response.status });
    }
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
};
```

- 로그아웃
```ts
export const POST = async () => {
  const res = NextResponse.json({ message: 'Signed out' }, { status: 200 });
  res.cookies.set('accessToken', '', EXPIRED_COOKIE_OPTIONS);
  res.cookies.set('userId', '0', EXPIRED_COOKIE_OPTIONS);
  return res;
};
```

<br></br>

### API 클라이언트 분리

```ts
// lib/api.ts
import axios from 'axios';

// 인증 관련 API (Next.js API 경유)
export const authAPI = axios.create({
  baseURL: '/api/auth',
  headers: {
    'Content-Type': 'application/json',
  },
});

// 일반 API (백엔드 직접 통신)
export const baseAPI = axios.create({
  baseURL: process.env.NEXT_PUBLIC_BACKEND_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

<br></br>

### Server Action을 통한 토큰 접근
클라이언트에서 호출 가능한 Server Action을 구현하여 HttpOnly Cookie에 안전하게 접근할 수 있도록 했다.

```typescript
'use server';

export const getAccessToken = async () => {
  const { cookies } = await import('next/headers');
  return (await cookies()).get('accessToken')?.value;
};
```

<br></br>

### Axios 인터셉터 통합
Server Action을 Axios 인터셉터에 통합하여 모든 API 요청에 자동으로 토큰을 포함시켰다.

```typescript
baseAPI.interceptors.request.use(async (config) => {
  const isServer = typeof window === 'undefined';

  if (isServer) {
    const { cookies } = await import('next/headers');
    const cookieStore = await cookies();
    const token = cookieStore.get('accessToken')?.value;
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  } else {
    const token = await getAccessToken();
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }

  return config;
});
```

<br></br>

### 화이트리스트 기반 Origin 검증
외부 스크립트의 무단 실행을 방지하기 위해 허용된 Origin만 Server Action을 실행할 수 있도록 제한했다.

예시에서는 카카오SDK 사용을 위한 스크립트 허용이 적용되어있다.

```js
const nextConfig = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Content-Security-Policy',
            value:
              "script-src 'self' 'unsafe-eval' 'unsafe-inline' https://t1.kakaocdn.net; object-src 'none';",
          },
        ],
      },
    ];
  },
```

<br></br>

## 학습 성과

### 보안과 개발 복잡도의 균형
- **보안 강화의 대가**: HttpOnly Cookie와 Server Action 도입으로 보안은 크게 향상되었지만, 개발 복잡도가 증가했다
- **적정 보안 수준**: 프로젝트의 특성과 위험도에 따라 적절한 보안 수준을 결정하는 것이 중요하다
- **단계적 보안 강화**: 기본 보안부터 시작해 필요에 따라 점진적으로 강화하는 접근법이 효과적이다

### Next.js 보안 기능 활용
- **Server Action의 CSRF 방지**: Next.js가 기본 제공하는 CSRF 토큰 검증 기능 활용
- **Cookie 보안 옵션**: `secure`, `sameSite`, `httpOnly` 등 다양한 보안 옵션 적절한 활용
- **서버/클라이언트 환경 분리**: 각 환경에 적합한 토큰 접근 방식 구현

### 웹 보안 이해도 향상
- **XSS와 CSRF 대응**: 실제 구현을 통한 웹 보안 취약점 이해 및 대응 능력 향상
- **토큰 관리 전략**: Access Token의 한계점 인식 및 보완 방법 학습
- **보안 검증**: 화이트리스트 기반 Origin 검증을 통한 추가 보안 계층 구축
