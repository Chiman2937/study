# 토큰 방식을 이용한 인증 시스템 구현

## 작업 환경

백엔드 API가 CORS를 허용하고 토큰을 Response Body로 반환하는 환경일 때 클라이언트에서 보안을 어느 수준까지 확보할 수 있는지 테스트 해보고자 했다.

<br></br>

## 문제 상황

기존 토큰 기반 인증 시스템에서 발생할 수 있는 보안 위협들을 검토했다.

<br></br>

### 주요 보안 위협
1. **XSS(Cross-Site Scripting)**: 악성 스크립트를 통한 토큰 탈취
2. **CSRF(Cross-Site Request Forgery)**: 인증된 사용자의 의도하지 않은 요청 실행
3. **토큰 노출**: 개발자 도구나 스크립트를 통한 토큰 접근

Storage 저장 방식으로는 이러한 위협에 취약하다는 문제가 있었다.

<br></br>

## 해결 방안 검토

### 1차 검토: HttpOnly Cookie 도입
XSS 공격을 방지하기 위해 스크립트로 접근 불가능한 HttpOnly Cookie를 사용하기로 결정했다.

```typescript
export const HTTPONLY_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax' as const,
  path: '/',
  maxAge: 60 * 60 * 6, // 6시간
};
```

<br></br>

### 2차 검토: 클라이언트 토큰 접근 문제
HttpOnly Cookie 사용 시 클라이언트에서 토큰에 접근할 수 없어 API 요청 시 Authorization 헤더를 설정할 수 없는 문제가 발생했다.

#### 검토한 해결책들

**1. Next.js API를 프록시로 활용**
- 모든 API 요청을 Next.js API를 경유하도록 구성
- ❌ 모든 HTTP 메서드와 상태 코드에 대한 처리 필요
- ❌ 웹 서버 비용 증가
- ❌ 네트워크 탭에서 실제 API 요청 확인 불가

**2. 토큰 접근 전용 Next.js API 제작**
```typescript
// app/api/token/route.ts
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function GET() {
  const cookieStore = await cookies();
  const token = cookieStore.get('accessToken')?.value;
  
  return NextResponse.json({ token });
}
```
- ❌ HttpOnly의 보안 의미 퇴색
- ❌ 토큰 접근 엔드포인트 노출

**3. 토큰 발급 시 요청 헤더에 미리 저장**
```typescript
// 로그인 응답에서 토큰 추출 후 axios 기본 헤더에 설정
const loginResponse = await axios.post('/api/auth/login', credentials);
const { accessToken } = loginResponse.data;

// axios 인스턴스의 기본 헤더에 토큰 설정
baseAPI.defaults.headers.common['Authorization'] = `Bearer ${accessToken}`;

// 이후 모든 요청에 자동으로 토큰이 포함됨
const userProfile = await baseAPI.get('/api/user/profile');
```

- ❌ Axios 인터셉터 로직과 분리 필요
- ❌ 추적성 저하 (토큰 설정과 요청 로직이 분산)

**4. Server Action 활용 (최종 선택)**
- ✅ 엔드포인트 노출 없음
- ✅ 인터셉터 로직 내에서 해결 가능
- ✅ Next.js 기본 CSRF 방지 지원

<br></br>

> Next.js의 서버 액션 CSRF 방지 기능

- 자동 CSRF 토큰: Next.js가 자동으로 생성하고 검증하는 토큰 시스템
- 쿠키-폼 데이터 검증: 요청 시마다 쿠키와 폼 데이터의 토큰을 비교
- Same-Origin 정책: 외부 도메인에서의 무단 호출 차단
- 서버 지시문 제한: 'use server'가 있는 함수만 실행 가능

<br></br>

## 최종 해결책

### 하이브리드 API 통신 구조
보안과 성능의 균형을 위해 API 특성에 따라 다른 통신 방식을 적용했다.

```
인증 관련 API: authAPI <=> Next.js API <=> Backend
일반 API:      baseAPI <=> Backend (직접 통신)
```

<br></br>

### 인증 API 프록시 구현
- 로그인
```ts
const BaseURL = process.env.NEXT_PUBLIC_API_BASE_URL;

export const POST = async (req: NextRequest) => {
  try {
    const body = await req.json();
    const response = await axios.post<AuthResponse>(`${BaseURL}/auth/signIn`, body);
    const { accessToken, user } = response.data;

    const res = NextResponse.json(user, { status: 200 });
    res.cookies.set('accessToken', accessToken, HTTPONLY_COOKIE_OPTIONS);
    res.cookies.set('userId', String(user.id), DEFAULT_COOKIE_OPTIONS);
    return res;
  } catch (err) {
    if (axios.isAxiosError(err) && err.response) {
      return NextResponse.json(err.response.data, { status: err.response.status });
    }
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
};
```

- 로그아웃
```ts
export const POST = async () => {
  const res = NextResponse.json({ message: 'Signed out' }, { status: 200 });
  res.cookies.set('accessToken', '', EXPIRED_COOKIE_OPTIONS);
  res.cookies.set('userId', '0', EXPIRED_COOKIE_OPTIONS);
  return res;
};
```

<br></br>

### API 클라이언트 분리

```ts
// lib/api.ts
import axios from 'axios';

// 인증 관련 API (Next.js API 경유)
export const authAPI = axios.create({
  baseURL: '/api/auth',
  headers: {
    'Content-Type': 'application/json',
  },
});

// 일반 API (백엔드 직접 통신)
export const baseAPI = axios.create({
  baseURL: process.env.NEXT_PUBLIC_BACKEND_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

<br></br>

### Server Action을 통한 토큰 접근
클라이언트에서 호출 가능한 Server Action을 구현하여 HttpOnly Cookie에 안전하게 접근할 수 있도록 했다.

```typescript
'use server';

export const getAccessToken = async () => {
  const { cookies } = await import('next/headers');
  return (await cookies()).get('accessToken')?.value;
};
```

<br></br>

### Axios 인터셉터 통합
Server Action을 Axios 인터셉터에 통합하여 모든 API 요청에 자동으로 토큰을 포함시켰다.

```typescript
baseAPI.interceptors.request.use(async (config) => {
  const isServer = typeof window === 'undefined';

  if (isServer) {
    const { cookies } = await import('next/headers');
    const cookieStore = await cookies();
    const token = cookieStore.get('accessToken')?.value;
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  } else {
    const token = await getAccessToken();
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }

  return config;
});
```

<br></br>

### 화이트리스트 기반 Origin 검증
외부 스크립트의 무단 실행을 방지하기 위해 허용된 Origin만 Server Action을 실행할 수 있도록 제한했다.

예시에서는 카카오SDK 사용을 위한 스크립트 허용이 적용되어있다.

```js
const nextConfig = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Content-Security-Policy',
            value:
              "script-src 'self' 'unsafe-eval' 'unsafe-inline' https://t1.kakaocdn.net; object-src 'none';",
          },
        ],
      },
    ];
  },
```

<br></br>

## 학습 성과

### 보안과 개발 복잡도의 균형점 찾기

보안 강화와 개발 복잡도는 반비례 관계에 있다는 것을 체감했다. HttpOnly Cookie와 Server Action 도입으로 보안은 크게 향상되었지만 개발 복잡도가 증가했다. 따라서 프로젝트의 특성과 위험도에 따라 적절한 보안 수준을 결정하는 것이 중요하다는 교훈을 얻었다.

### Next.js 보안 기능 활용 경험

Server Action의 자동 CSRF 방지, Cookie 보안 옵션(secure, sameSite, httpOnly) 등 Next.js가 제공하는 다양한 보안 기능을 실제 프로젝트에 적용해볼 수 있었다.

### 웹 보안 이해도 향상

XSS와 CSRF 공격 원리를 이해하고 이에 대한 실제 대응 방법을 구현하면서 웹 보안에 대한 전반적인 이해도가 향상되었다.
