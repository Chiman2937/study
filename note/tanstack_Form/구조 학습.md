# Tanstack Form 공부

Tanstack Form 공식문서에서 제공해주는 예시를 테스트 해보았다.

https://tanstack.com/form/latest/docs/overview

React Hook Form이 비제어 컴포넌트를 권장하는 방식인데에 비해 Tanstack Form은 제어 컴포넌트 방식을 차용하고 있다.

그리고 React Hook Form에서 제어 컴포넌트를 다룰 때 사용하던 Controller와 동일하게 RenderProps 패턴을 적용하고 있다.

파라미터 이름도 field로 동일하고, field를 통해 value나 onChange 등 다양한 속성을 제공해줘서 꺼내 쓰는 방식이다.

```ts
...
<div>
  <form.Field
    name="lastName"
    children={(field) => (
      <>
        <label htmlFor={field.name}>Last Name:</label>
        <input
          id={field.name}
          name={field.name}
          value={field.state.value}
          onBlur={field.handleBlur}
          onChange={(e) => field.handleChange(e.target.value)}
        />
        <FieldInfo field={field} />
      </>
    )}
  />
</div>
...
```

문제 1

예제에서는 children을 props로 전달하는 것은 react에서 권장하지 않는 패턴이며 실제로 에러를 발생시킨다.

<img width="896" height="62" alt="image" src="https://github.com/user-attachments/assets/d565c273-e89e-44d8-a829-9e9278b8db4c" />

따라서 children 부분은 예제와 다르게 아래처럼 작성해준다.

```tsx
<form.Field name='lastName'>
  // children을 props로 넘겨주지 말기
  {(field) => (
    <>
      <label htmlFor={field.name}>Last Name:</label>
      <input
        id={field.name}
        name={field.name}
        value={field.state.value}
        onBlur={field.handleBlur}
        onChange={(e) => field.handleChange(e.target.value)}
      />
      <FieldInfo field={field} />
    </>
  )}
</form.Field>
```

문제 2

React Hook Form은 필드가 업데이트될때 전체필드가 리렌더링 되는 구조를 가지고 있지만 기본적으로 비제어 컴포넌트 패턴을 권장하기에 단점을 최소화 할 수 있는 반면,

Tanstack Form은 필드가 업데이트 될 때 해당 필드만 리렌더링 되는 구조를 가지고 있고, 기본적으로 제어 컴포넌트 패턴을 적용한다.

이 부분은 React의 철학과 Tanstack Form의 철학이 더 잘 맞는다고 생각이 된다.

어쨋든 여기서 문제가 되는 부분은 Tanstack Form의 구조상 구조가 복잡해질 수 밖에 없다는 것이다.

FormField의 자식은 field 객체를 받아서 그 내부의 value, event 등을 사용해야 하기 때문에 컴포넌트의 구조가 복잡해지면 코드가 너무 더러워질 수 있다는 단점이 있다.

공식문서만 봐도 기본 요소를 사용한 예제 구문인데 코드를 읽는것이 마냥 편하지는 않았다.


그래서 이 문제를 해결하기 위해 떠올린 방법은 아래와 같다.

```tsx
<FormField name='email'>
  <FormLabel required>이메일</FormLabel>
  <FormInput placeholder='email@example.com' type='email' />
  <FormHint />
</FormField>
```

이 구조를 실현시키려면 FormLabel, FormInput, FormHint는 내부에서 알아서 field 객체를 받아와야하는 구조다.

그러면 결국 FormField는 Tanstack Form의 form.Field 컴포넌트에서 field를 받아오고, 그것을 하위 컴포넌트에 전달하는 구조로 만들어야한다.

field 객체의 타입부터 확인해봤다.

<img width="994" height="317" alt="image" src="https://github.com/user-attachments/assets/1ab9e7d1-7e81-4ca0-814e-116ff8e02437" />

FieldAPI라는 Type을 사용하고 있길래 이걸 바탕으로 type 선언을 해봤다.

```tsx
interface FormFieldContextType {
  field: FieldApi
}
```

<img width="997" height="86" alt="image" src="https://github.com/user-attachments/assets/1700e90c-ab87-4cbc-8f9b-a279f5821dbd" />

이런 오류가 발생하길래 생각해보니 FieldApi라는 타입은 form.Field 컴포넌트에 name과 validators 속성을 지정했을 때 내부에서 동적으로 생성하는 Type이름일 테니 props로 전달받는 type으로는 적절하지 않겠다라는 생각이 들었고, 다른 Type을 찾아보았다.

다행히 예제 구문에 field를 Props를 넘겨주는 구문이 있었다.

```tsx
<FieldInfo field={field} />
```

<img width="325" height="42" alt="image" src="https://github.com/user-attachments/assets/611a3d57-2946-4ddc-bb35-56dfc67f770a" />

`AnyFieldApi` 라는 Type을 사용한 모습이다.

```tsx
interface FormFieldContextType {
  field: AnyFieldApi
}
```

이제 field 안에서 어떤 값을 꺼내 쓸 수 있는지 확인해봐야 하는데, 일단 먼저 Input 컴포넌트부터 만들어보기로 했다.

input에서 validation 통과: 파란색 테두리 / 실패: 빨간색 테두리

이 스타일을 적용하려면 error 값이 어디서 어떻게 사용해야하는건지 확인해봐야 했다.

일단 예제 구문을 보면 field.state.meta 에서 여러가지 값을 받아오고 있는 것을 알 수 있다.

```tsx
function FieldInfo({ field }: { field: AnyFieldApi }) {
  return (
    <>
      {field.state.meta.isTouched && !field.state.meta.isValid ? (
        <em>{field.state.meta.errors.join(', ')}</em>
      ) : null}
      {field.state.meta.isValidating ? 'Validating...' : null}
    </>
  );
}
```

그래서 field.state.meta를 console에 찍어보면 뭐가나오는지 확인해봤다.

<img width="710" height="215" alt="image" src="https://github.com/user-attachments/assets/0ebfd376-234b-4464-96af-2048b9113905" />

에러를 표시해주는게 errorMap이랑 errors가 있는데... 무슨 차이인지 모르겠어서 공식문서를 찾아봤다.


> In the example above, we are validating different things on the same field at different times (at each keystroke and when blurring the field). Since field.state.meta.errors is an array, all the relevant errors at a given time are displayed. You can also use field.state.meta.errorMap to get errors based on when the validation was done (onChange, onBlur etc...). More info about displaying

> It's worth mentioning that our errors array and the errorMap matches the types returned by the validators. This means that:

errorMap과 errors는 같은 유효성 결과를 보여주지만, errors는 현재 시점에서 수행된 모든 validation의 에러를 배열에 담아서 관리한다는 말인것 같다.

사실 error가 발생했는지 아닌지가 중요한거라서 errorMap의 onChange를 사용해주면 문제없어 보인다.

문제 3: form.field 컴포넌트를 커스텀 컴포넌트로 분리

form.field를 별도의 커스텀 컴포넌트로 분리하고, name만 넘겨주면 field 객체를 사용할 수 있게 만들고 싶었다.

그럼 FormField 컴포넌트를 이렇게 만들어야되는데..

```
const FormField = ({ form, name, field, children, className }: FormFieldProps) => {
  return (
    <FormFieldContext.Provider value={{ field }}>
      <form.Field>
      {children}
      </form.Field>
    </FormFieldContext.Provider>
  );
};

```

문제는 form이라는 컴포넌트를 props로 어떻게 전달하느냐가 문제다. form은 최상위 컴포넌트에서 아래와 같이 생성되기 때문이다.

```tsx
  const form = useForm({
    defaultValues: {
      firstName: '',
      lastName: '',
    },
    onSubmit: async ({ value }) => {
      // Do something with form data
      console.log(value);
    },
  });
```

form이 이런 type을 가지고 있긴 한데... 동적으로 생성되는 type이어서 이런 type을 쓰는 의미가 없다(제네릭으로 동작)

<img width="433" height="316" alt="image" src="https://github.com/user-attachments/assets/4089380e-fa7e-4eb5-a9ed-cbc9b8c65b8d" />

그래서 이런 경우를 해결하는 방법에 대해 공식문서에서 찾아봤다.


https://tanstack.com/form/latest/docs/framework/react/guides/form-composition



.....여기까지 작성(2025-11-30)
