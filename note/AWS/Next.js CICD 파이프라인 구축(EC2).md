# 📜 Next.js CICD 파이프라인 구축 과정(EC2)

## 💡 작업 배경

지난 중급프로젝트까지는 Vercel로 간편하게 배포하면서 느낀 점들은 다음과 같다.

### 장점
사용이 편하다.
깃허브에 푸시만 하면 자동으로 배포되고, 도메인 연결되는 작업은 처음 배포해보는사람도 금방 적용할 수 있을만큼 간단했다.

### 단점
자유도가 부족하다.
기본 설정은 Vercel 시스템을 그대로 따라야 하기 때문에 커스터마이징이 제한적이다.
협업 환경이 어렵다.
백엔드팀이 AWS를 사용하는 경우가 많은데, Vercel 배포 시 공통된 이해를 바탕으로 한 협업환경 구성이 어렵다
실무 경험의 한계
완성된 서비스만 사용하다보니 실제 인프라에 대한 깊은 이해가 부족하다고 느꼈다.

CICD를 직접 경험해본다면 웹 서비스 운영에 대해 한층 더 깊이 이해할 수 있을 것이라고 생각했기 때문에
가장 많이 사용하는 서비스인 AWS로 직접 CICD 작업을 해보기로 했다.

## 💡 구현 목표
이번 작업의 핵심 목표는 "완성되어있는 서비스를 바로 사용하는것이 아닌, 구조를 직접 설계하고 코드 작성해보기" 였다.
CICD를 직접 경험해보면 웹 서비스 운영에 대해 한층 더 깊이 이해할 수 있을 것이라고 생각했다.

## 💡 서비스 선정
AWS에서는 다양한 서비스들을 제공하고있었고, 내 프로젝트에 어떤 서비스가 적합할 지 고민해봐야 했다.

고려했던 AWS 서비스들
- S3: 정적 파일 호스팅
- EC2: 가상 서버 인스턴스
- CodeDeploy: 자동 배포 서비스
- CodePipeline: CI/CD 파이프라인
- Amplify: 풀스택 애플리케이션 배포

나의 프로젝트 특성
- 프레임워크: Next.js(서버환경 필요)

서버환경이 필요한 프로젝트이기 때문에 S3는 사용이 불가능했다.
또 CodeDeploy와 CodePipeline을 사용하면 쉽게 배포가 가능했지만, 하나부터 열까지 직접 구현해보고싶었기에 EC2를 사용해 배포를 해보기로 했다.

## 💡 구현 과정

### 첫번째 시도 - EC2에서 직접 빌드하기
처음 구상한 구조는 정말 단순했다.

github action 실행 => EC2 인스턴스 접속 => git Repo에서 pull => 의존성 설치 및 빌드 실행 => PM2 프로세스 실행

하지만 이 방식에는 치명적인 단점이 있었다.

#### 문제점

EC2 프리티어 메모리를 사용하다보니 안그래도 메모리가 부족한데(1GB), 프로젝트 빌드 시 메모리를 너무 많이 사용한다는 점이었다.
실제로 로컬 환경에서 직접 빌드는 해보면 알 수 있지만 기본 400mb는 가볍게 먹고 들어가고, 1GB를 넘길때도 있다.

이것은 빌드 도중 OOM 을 유발했고 서비스 STOP 및 불필요한 서버 재가동 작업을 해줘야했다.

그리고 원본소스코드와 프로세스 실행에 필요한 빌드파일들 모두 서버에 저장되는 방식이다 보니 디스크 사용량도 결코 적지 않았다.

또 프로젝트의 규모가 크지 않아도 빌드 시간이 오래 걸리는 문제가 있었다.

해결방법

근본적인 원인은 "EC2 인스턴스에서 직접 Build 실행" 하는 구조에 있었다.

이 문제를 해결하기 위해 github action이 실행된 후 즉시 build하며 build된 파일만 EC2 서버에 업로드 하는 방식에 대해 검토해보았다.

github action 실행 => npm ci / npm run build => EC2 서버 업로드 => PM2 프로세스 실행

이 방식을 적용하면 EC2 서버가 메모리를 불필요하게 많이 사용하는 문제를 막을 수 있고, 소스코드는 업로드 하지 않으므로 디스크도 절약할 수 있었다.

하지만 개선의 여지가 있다고 판단해 최적화 작업을 한번 더 진행해보았다.

github action 실행 => npm ci / npm run build => npm prune --dev => 파일 고압축 => EC2 서버 업로드 => 압축 해제 => PM2 프로세스 실행

첫번째는 프로세스 실행에 정말 필요한 파일만 서버에 업로드 하는 것이었다.
node_modules에는 개발에만 필요한 의존성과 프로던션용 의존성이 구분 되는데, 이 설정은 package.json 설정에 의해 결정된다.
어쨋든 프로덕션 의존성만 포함하여 EC2 서버에 업로드하면 더 효율적일 것이라고 생각했다.

또 2번째 개선안에서는 빌드 파일들을 그대로 EC2 서버에 업로드 하는 방식이었는데, 파일을 압축하고 업로드 하면 EC2 메모리의 사용량을 더욱 줄일 수 있지 않을까 싶었다.

이 방식으로 최종 cicd 구문을 적용하여 메모리, 디스크 사용량을 대폭 감소 시킬 수 있었고, 이에 따라 빌드 시간도 단축할 수 있었다.

마지막 문제는 https 적용이었다.

aws 기본 url을 사용하면 자동으로 https까지 적용되지만, 나는 도메인을 구매했기 때문에 직접 https 연동까지 해줘야했다.

aws에서 ACM(AWS Certificate Manager)를 통해 인증서를 발급받을 수 있긴 하지만 무료로 사용하려면 AWS 내부에서만 사용가능하고 인증서 파일을 다운로드 받지 못한다는 문제가 있었다.
CloudFront, ALB등에서만 사용가능한데 ALB는 유료이고, CloudFront는 cdn이기 때문에 EC2 환경과는 잘 맞지 않았다.(해당 트러블 슈팅은 추후에 등록 예정)

그래서 인증서에 대해 좀 더 알아보았는데, Let's Encrypt 라는 비영리 기관에서 인증서를 무료로 발급해준다는 것을 알았다.
유효기간이 3개월로 짧지만, 주기적 재발급 로직을 적용한다면 사용하는데 문제는 없을 듯 했다.

여기에 nginx config 까지 도입하여 http 접속시 https로 redirect 하는 구문과 인증서를 붙여주는 작업까지 적용해 https 적용을 구현할 수 있었다.
