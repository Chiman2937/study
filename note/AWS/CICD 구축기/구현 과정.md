# 설계 구조

EC2 서버 자동 배포 구현을 위해 아래와 같은 구조를 구상했다.

```
github action 실행 => EC2 인스턴스 접속 => git Repo에서 pull => 의존성 설치 및 빌드 실행 => PM2 프로세스 실행
```

<br></br>

# 문제점

## EC2 프리티어 메모리의 부족

안그래도 메모리가 부족한데(1GB) 프로젝트 빌드 시 메모리를 너무 많이 사용했다.

실제로 로컬 환경에서 직접 빌드는 해보면 알 수 있지만 기본 400mb는 가볍게 먹고 들어가고, 1GB를 넘길때도 있었다.

이것은 빌드 도중 OOM 을 유발했고 서비스 STOP 및 불필요한 서버 재가동 작업을 해줘야했다.

## 과한 디스크 사용량
원본소스코드와 프로세스 실행에 필요한 빌드파일들 모두 서버에 저장되는 방식이다 보니 디스크 사용량도 결코 적지 않았다.

## 오래걸리는 빌드 시간
EC2 서버의 메모리를 사용하다보니 프로젝트의 규모가 크지 않아도 빌드 시간이 오래 걸리는 문제가 있었다.

<br></br>

# 문제점 개선 - 빌드 파일을 EC2서버에 업로드하기

근본적인 원인은 "EC2 인스턴스에서 직접 Build 실행" 하는 구조에 있었다.

이 문제를 해결하기 위해 github action이 실행된 후 즉시 build하며 build된 파일만 EC2 서버에 업로드 하는 방식에 대해 검토해보았다.

```
github action 실행 => npm ci / npm run build => EC2 서버 업로드 => PM2 프로세스 실행
```

이 방식을 적용하면 EC2 서버가 메모리를 불필요하게 많이 사용하는 문제를 막을 수 있고, 소스코드는 업로드 하지 않으므로 디스크도 절약할 수 있었다.

<br></br>

# 추가 개선 - production용 node modules만 서버에 업로드 하기

실제 프로덕션에는 devDependencies는 필요가 없기 때문에 프로덕션용 패키지만 서버에 업로드 하는 방식을 사용하고자 했다.

```
npm install --production
```

위의 명령어를 이용해 프로덕션 용 패키지만 별도로 설치가 가능한데, 여기서 또 문제가 발생했다.

```
action 실행 => npm install => npm run build => rm -rf node_modules(의존성 삭제) => npm install --production
```

프로젝트 빌드 시의 검증을 위해 전체 패키지를 이미 한번 설치했는데, EC2 서버 업로드를 위해 프로덕션용 패키지 설치를 한번 더 실행하게 되면 빌드 시간이 더 늘어나버리는 문제였다.

이 문제를 해결하기 위한 방법을 찾아보았고, 이미 설치된 node modules에서 devDependencies만 삭제하는 명령어를 알게 되었다.

이 명령어는 기존에 이미 설치되어있는 node modules에서 개발 의존성을 제거하는 명령어이다.

```
npm prune --omit=dev
```

의존성을 새로 설치하는 것이 아니라 기존에 설치되어있던 파일을 삭제하는 것이므로 작업 시간을 훨씬 더 단축할 수 있었다.

## 변경 전 용량
```
du -sh .[^.]* * 2>/dev/null | sort -hr
925M    node_modules
213M    .next
1.5M    public
616K    package-lock.json
8.0K    config
4.0K    package.json
4.0K    next.config.ts
```

## 변경 후 용량
```
du -sh .[^.]* * | sort -hr
559M    node_modules
213M    .next
1.5M    public
616K    package-lock.json
8.0K    config
4.0K    package.json
4.0K    next.config.js
```

약 350M 개선된 것을 볼 수 있다.

<br></br>

# 추가 개선 2 - 빌드 파일 압축하기

첫번째 개선 내용에서 node_modules 최적화를 진행했지만, 여전히 900Mb 가까이 되는것을 알 수 있다.

현재 EC2 서버에 업로드하는 파일들은 빌드파일, node modules, public 등으로 구성되어있다.

특히나 Next.js 프로젝트는 모듈 크기가 크다.

node_modules 용량 순 정렬 검색 결과를 확인해보면, next 관련 패키지 용량만 거의 420M가 되는것을 볼 수 있다.

```
ubuntu@ip-172-31-43-170:~/project-app$ du -sh node_modules/* | sort -hr | head -20
272M    node_modules/@next
150M    node_modules/next
```

이런 경우 인터넷이 느린 환경에서는 작업 시간이 지연될 수 있고, AWS 네트워크 전송 비용에도 불리 할 것이라고 생각했다.

따라서 파일들을 압축해서 EC2 서버에 업로드 후, 압축 해제해서 사용하는 방법을 시도해보았다.

```
# 압축
cd deploy-package
tar -czf ../production-app.tar.gz --exclude='node_modules/*/.cache' --exclude='node_modules/*/coverage' .
```

deploy-package 디렉토리는 /public, /.next 등 프로세스 실행에 필요한 파일들을 모아놓은 임시 디렉토리이고, 이 디렉토리에서 압축을 진행하는 방식이다.

이 때 /.cache 와 /coverage는 압축 대상에서 제외하여 용량 최적화를 조금 더 진행 해주었다.

linux 환경에서 tar는 다수의 파일을 디렉토리 구조, 파일 속성 등을 보존하면서 하나의 파일로 묶는데 사용되는 파일 형식이다.

| 명령어 | 압축 방식 | 압축 시간 | CPU/메모리 사용량 | 압축률 | 파일 확장자 | 용도 |
|--------|-----------|-----------|-------------------|--------|-------------| --- |
| tar cf | 압축 없음 (묶기만) | 매우 빠름 | 매우 적음 | 거의 없음 | .tar | 단순 묶기 |
| tar czf | gzip 압축 | 보통 | 보통 | 중간 (30-60%) | .tar.gz 또는 .tgz | 빠른 백업 |
| tar cjf | bzip2 압축 | 느림 | 많음 | 높음 (40-70%) | .tar.bz2 | (잘 안쓰임 / 장기 보관용) | 
| tar cJf | xz 압축 | 매우 느림 | 매우 많음 | 매우 높음 (50-80%) | .tar.xz | 장기 보관 |

이 방식으로 최종 cicd 구문을 적용하여 메모리, 디스크 사용량을 대폭 감소 시킬 수 있었고, 이에 따라 빌드 시간도 단축할 수 있었다.

개선 지표를 확인하기 위해 디버그 구분도 적용해서 모니터링 해보았다.


<details>
<summary>메모리 사용량 모니터링 로그</summary>

EC2 서버 업로드 시 메모리 사용량 (약 30mb 사용 / Peak)
```
[DEBUG][GHA] 🔍 복사 전 EC2 메모리: 586Mi/914Mi
[MONITOR] 03:50:57 - 메모리: 580MB/914MB (63.4%)
[MONITOR] 03:50:58 - 메모리: 580MB/914MB (63.4%)
[MONITOR] 03:50:59 - 메모리: 580MB/914MB (63.4%)
[MONITOR] 03:51:00 - 메모리: 580MB/914MB (63.4%)
[MONITOR] 03:51:01 - 메모리: 572MB/914MB (62.5%)
[MONITOR] 03:51:02 - 메모리: 577MB/914MB (63.1%)
[MONITOR] 03:51:03 - 메모리: 583MB/914MB (63.7%)
[MONITOR] 03:51:04 - 메모리: 583MB/914MB (63.7%)
[MONITOR] 03:51:05 - 메모리: 602MB/914MB (65.8%)
[MONITOR] 03:51:06 - 메모리: 599MB/914MB (65.5%)
[MONITOR] 03:51:07 - 메모리: 597MB/914MB (65.3%)
[MONITOR] 03:51:08 - 메모리: 592MB/914MB (64.7%)
[MONITOR] 03:51:09 - 메모리: 594MB/914MB (64.9%)
[MONITOR] 03:51:10 - 메모리: 591MB/914MB (64.6%)
[MONITOR] 03:51:11 - 메모리: 591MB/914MB (64.6%)
[MONITOR] 03:51:12 - 메모리: 591MB/914MB (64.6%)
[MONITOR] 03:51:13 - 메모리: 592MB/914MB (64.7%)
[MONITOR] 03:51:15 - 메모리: 592MB/914MB (64.7%)
[MONITOR] 03:51:16 - 메모리: 592MB/914MB (64.7%)
[MONITOR] 03:51:17 - 메모리: 592MB/914MB (64.7%)
[MONITOR] 03:51:18 - 메모리: 578MB/914MB (63.2%)
[MONITOR] 03:51:19 - 메모리: 578MB/914MB (63.2%)
[MONITOR] 03:51:20 - 메모리: 578MB/914MB (63.2%)
[MONITOR] 03:51:21 - 메모리: 578MB/914MB (63.2%)
[DEBUG][GHA] 🔍 복사 후 EC2 메모리: 572Mi/914Mi
```

EC2 서버에서 압축해제 시 메모리 사용량(약 60MB 사용 / Peak)
```
[DEBUG][EC2] 🔍 압축 해제 전 메모리: 334Mi/914Mi
[MONITOR] 03:51:28 - 메모리: 334MB/914MB (36.5%)
[MONITOR] 03:51:29 - 메모리: 408MB/914MB (44.6%)
[MONITOR] 03:51:30 - 메모리: 341MB/914MB (37.3%)
[MONITOR] 03:51:31 - 메모리: 318MB/914MB (34.7%)
[MONITOR] 03:51:32 - 메모리: 319MB/914MB (34.9%)
[MONITOR] 03:51:33 - 메모리: 317MB/914MB (34.6%)
[MONITOR] 03:51:34 - 메모리: 328MB/914MB (35.8%)
[MONITOR] 03:51:35 - 메모리: 343MB/914MB (37.5%)
[MONITOR] 03:51:36 - 메모리: 343MB/914MB (37.5%)
[MONITOR] 03:51:37 - 메모리: 343MB/914MB (37.5%)
[DEBUG][EC2] 🔍 압축 해제 후 메모리: 343Mi/914Mi
```

</details>

<details>
<summary>디스크 사용량</summary>

```
====================== 📦 패키징 정보 ======================
Full node_modules size         | 929M
Production node_modules size   | 563M
Deploy package size            | 791M
Final compressed size          | 176M
=============================================================
```

</details>

최종 개선 지표

| 항목 | 개선 전 | 개선 후 | 개선 지표 |
|---|---|---|---|
| 메모리 사용량(Peak) | 400MB 이상 | 약 40MB | 약 90% 감소 |
| 디스크 사용량(Peak) | 약 1.2GB | 약 790MB | 약 35% 감소 |
| 배포 시간 | 3분 이상 | 2분 30초 내외 | 약 20% 감소 |
| 네트워크 사용량 | 약 790GB | 약 176MB | 약 75% 감소 |
