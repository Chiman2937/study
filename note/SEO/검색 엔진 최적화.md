# 문제 상황
Next.js 13 App Router로 SSR을 구현하면서 검색 엔진 최적화(SEO)를 위한 메타데이터 설정을 진행했다.

정적 페이지의 기본 메타데이터는 쉽게 설정할 수 있었지만, 사용자 프로필, 상품 상세 페이지 등 동적 콘텐츠에서는 각 페이지의 데이터에 맞는 맞춤형 메타데이터가 필요했다.

특히 소셜 미디어 공유 시 최적화된 미리보기를 제공하기 위한 Open Graph 설정과 검색 엔진 크롤링을 위한 완전한 Sitemap 구성이 필요했다.

<br></br>

# 분석 및 접근 방향
## SEO 최적화 요구사항

- 동적 메타데이터: 각 페이지 콘텐츠에 맞는 title, description 자동 생성
- Open Graph 최적화: 소셜 미디어 공유 시 풍부한 미리보기 제공
- 완전한 Sitemap: 정적 페이지 + 동적 생성 페이지 모두 포함
- 검색엔진 친화적: robots.txt, canonical URL 등 기본 SEO 요소

## Next.js App Router의 특징 활용
- generateMetadata 함수로 서버사이드 메타데이터 생성
- 동적 라우트에서 params 기반 데이터 페칭
- 빌드 시점과 런타임 모두에서 메타데이터 처리 가능

<br></br>
# 구현 과정

## 1. 동적 메타데이터 생성

- generateMetadata 함수를 사용하여 프로필 페이지 동적 메타데이터를 생성
- Open Graph 최적화

  - 타입별 구분: 프로필, 상품, 일반 페이지별 적절한 og:type 설정
  - 이미지 최적화: 각 콘텐츠의 대표 이미지를 og:image로 활용
  - 구조화된 정보: 팔로워 수, 리뷰 개수 등 핵심 수치를 description에 포함

```ts
export const generateMetadata = async ({ params }: PageProps): Promise<Metadata> => {
  const { userId } = await params;
  const profileId = Number(userId);
  if (Number.isNaN(profileId)) {
    notFound();
  }

  // headers에서 현재 URL 가져오기
  const headersList = headers();
  const host = (await headersList).get('host') || process.env.DOMAIN;
  const currentUrl = `https://${host}/user/${userId}`;

  try {
    const userProfile = await getUserProfileAPI({ userId: profileId });

    const { nickname, description, followersCount, reviewCount } = userProfile;

    const metaTitle = `${nickname}님의 프로필 | mogazoa`;
    const metaDescription = `${nickname}님의 프로필 | 팔로워 ${followersCount}명 • 리뷰 ${reviewCount}개\n\n${description}\n\nmogazoa에서 다양한 상품 리뷰와 정보를 확인하세요`;

    return {
      title: metaTitle,
      description: metaDescription,
      keywords: [nickname, '프로필', '리뷰', '상품평가', 'mogazoa'],
      openGraph: {
        title: metaTitle,
        description: metaDescription,
        siteName: 'mogazoa',
        locale: 'ko_KR',
        type: 'profile',
        url: currentUrl,
        images: userProfile.image
          ? [
              {
                url: userProfile.image,
                width: 200,
                height: 200,
                alt: `${nickname}님의 프로필 사진`,
              },
            ]
          : [],
      },
      robots: {
        index: true,
        follow: true,
      },
      alternates: {
        canonical: currentUrl,
      },
    };
  } catch (error) {
    console.error('Failed to fetch user profile for metadata:', error);

    return {
      title: `사용자 프로필 | mogazoa`,
      description: '사용자의 프로필과 리뷰를 확인해보세요.',
      openGraph: {
        title: '사용자 프로필 | mogazoa',
        description: '사용자의 프로필과 리뷰를 확인해보세요.',
        url: currentUrl,
        type: 'profile',
      },
    };
  }
};

```

## 2. sitemap 생성

### 정적 페이지 우선순위 결정
```
const staticPages = [
  {
    url: baseUrl,
    lastModified: new Date(),
    changeFrequency: 'daily' as const,
    priority: 1,        // 메인 페이지 최고 우선순위
  },
  {
    url: `${baseUrl}/compare`,
    lastModified: new Date(),
    changeFrequency: 'daily' as const,
    priority: 0.9,      // 핵심 기능 페이지
  },
];
```

### 동적 페이지 전체 수집 시스템
```ts
const getAllProducts = async () => {
  const products = [];
  let nextCursor = 0;
  let totalFetched = 0;
  
  while (true) {
    console.log(`🔄 Fetching products with cursor: ${nextCursor}`);
    try {
      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_BASE_URL}/products?cursor=${nextCursor}`,
      );
      const data = await response.json();
      
      console.log(`📦 Fetched ${data.list.length} products`);
      totalFetched += data.list.length;
      products.push(...data.list);

      // 더 이상 데이터가 없으면 종료
      if (!data.nextCursor) {
        console.log(`✅ Finished! Total products: ${totalFetched}`);
        break;
      }
      nextCursor = data.nextCursor;
    } catch (error) {
      console.error('Failed to fetch products:', error);
      break;  // 에러 시에도 기존 수집된 데이터는 활용
    }
  }

  return products;
};
```

### 메타데이터 최적화

```ts
const productPages = products.map((product) => ({
  url: `${baseUrl}/products/${product.id}`,
  lastModified: new Date(product.updatedAt),  // 실제 업데이트 시간 반영
  changeFrequency: 'weekly' as const,         // 상품 정보 변경 주기
  priority: 0.7,                              // 상품 페이지 우선순위
}));
```

<br></br>

### 최종 결과

<img width="125" height="94" alt="image" src="https://github.com/user-attachments/assets/165145ca-581b-4847-a72d-5debcb479ee5" />

lighthouse 측정 시 `검색엔진 최적화` 항목 100점으로 개선

- 자동화: 새 상품 추가 시 sitemap 자동 갱신
- 로깅: 빌드 과정에서 데이터 수집 현황 실시간 확인

<br></br>
