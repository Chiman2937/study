# 📝 팀 컨벤션 설정 - (1) 기술 스택 선정
팀원들이 모두 공통된 작업을 진행해야한다고 생각했기 때문에 다른 컨벤션을 설정하기 전 먼저 어떤 기술을 적용할 것인지에 대해 팀원들과 고민해보았다.

## 💡 개발 언어, 기본 라이브러리 선정
### ✅ 개발 언어
TypeScript를 배우지 않은 현 시점에는 Javascript + Vite React 밖에 없었다.

#### ❓ Vite를 사용한 이유
1. React에서 공식으로 권장하고 있는 사항
2. CRA는 더 이상 권장되거나 유지보수되지 않음
3. Vite는 ES 모듈 기반으로 작동하며, 처음부터 모든 파일을 번들링 하지 않기 때문에 CRA에 비해 훨씬 빠르게 개발 서버가 구동됨
4. 코드 수정 시 전체 페이지 리로드 없이 변경된 모듈만 갱신되며, 스타일이나 텍스트 변경도 즉시 반영되어 빠른 피드백 가능

### ✅ 스타일링
이번 프로젝트에서는 스타일링을 적용하기 위해 Sass(Scss)를 적용하였다.

#### ❓ Sass를 사용한 이유
1. 기초 프로젝트를 시작하기 직전까지 사용한 것이 기본 css, css module 이었기 때문에 적응하기 빠를 것이라고 판단
2. 공통적으로 적용 가능한 스타일은 mixins 로 관리할 수 있어서 유지보수가 간편할 것이라고 예상
4. 각 컴포넌트 별로 scss파일을 구성하고 모듈화 하기에 적합할 것이라고 판단

### ✅ 데이터 패칭
fetch를 사용하는 대신 Axios를 사용해보았다.

#### ❓ Axios를 사용한 이유
1. fetch는 스프린트 미션을 통해 어느정도 익숙해졌다고 생각했기 때문에, Axios를 사용해보면서 간편한 라이브러리에 적응해 보고 싶었다.
2. fetch는 JSON 파싱을 별도로 해주어야 하지만 Axios는 JSON 파싱까지 진행해 주기 때문에 더 간편하다고 생각했다.
3. interceptors 기능 제공으로 요청/응답에 대한 관리가 쉬움

### ✅ 라우팅 처리
SPA 환경에서 페이지 라우팅 처리를 위해 React Router를 적용하였다.

#### ❓ React Router를 사용한 이유
1. React의 SPA환경에서 페이지를 이동하기 위해서는 `window.location.bash`를 이용한 라우팅을 직접 구현해야 했다.
2. 직접 구현하는 것 보다 React Router를 활용하는것이 안정적이고 유지보수에 유리할 것이라고 판단(404처리, 동적 라우팅 등을 전부 직접 구현 필요)

## 💡 코드 작성 스타일 통합
코드 작성 스타일을 정하지 않으면, 담당자마다 코드 스타일을 다르게 작성하게 될 것이라고 생각했고, 유지보수 측면에서 굉장히 불리할 것이라고 생각했다.

그리고 이것을 자동으로 준수되게 만들지 않으면 의미가 없다고 생각했기 때문에 Prettier, Eslint, Husky 등을 이용해 통일 시켜 보았다.

### Prettier
Prettier는 코드 스타일을 자동으로 정해진 규칙에 따라 일관되게 정리해주는 포맷터이다.

이번 프로젝트에서는 팀 전체의 코드 가독성과 협업 효율을 높이기 위해 다음과 같은 규칙을 중심으로 Prettier를 적용했다.

|설정 항목|	값	|설명|
|---|---|---|
|`tabWidth`|	2	|들여쓰기를 2칸으로 설정합니다.
|`semi`|	true	|코드 끝에 항상 세미콜론을 붙입니다.
|`singleQuote`|	true	|문자열에 작은따옴표(')를 사용합니다.
|`jsxSingleQuote`|	true	|JSX에서도 작은따옴표를 사용합니다.
|`printWidth`|	100	|한 줄에 최대 100자까지만 작성되도록 줄을 자동으로 개행합니다.
|`bracketSpacing`|	true	|객체 리터럴에서 중괄호와 속성 사이에 공백을 추가합니다. 예: { foo: bar }
|`arrowParens`|	"always"	|화살표 함수의 매개변수에 괄호를 항상 붙입니다. 예: (x) => x + 1|
|`proseWrap`|	"preserve"	|마크다운 등에서 자동 줄바꿈을 하지 않고 작성한 그대로 유지합니다.

1. semicolon : 어떤 코드의 종료지점이 어디인지 명확하게 판별할 수 있기 때문에 가독성에 좋을 것이라고 판단했다.
2. singleQuote: 쌍따옴표보다 작은따옴표로 작성하는것이 가독성에 더 좋을 것이라고 판단했다.
3. printWidth: 범용적으로 사용하는 것이 100 이라고 해서 적용해보았고, 실제로 프로젝트를 진행할 때 코드를 읽기 편했던 것 같다.
4. brackSpacing: 중괄호와 속성 사이에 공백이 없을 때 가독성이 떨어졌던 기억이나서 적용해 보았다.
5. arrowParens: 뒤에 서술할 예정이지만, 기본 변수 선언은 const로 진행하며 함수도 const를 이용한 화살표 함수로 선언하기로 정했기 때문에 가독성을 위해 이 규칙은 반드시 필요하다고 생각했다.

### ESLint
ESLint는 코드를 작성할 때 권장하지 않는 패턴이나 잠재적인 오류를 자동으로 감지해 경고 또는 오류 메시지로 알려주는 정적 분석 도구이다.

이를 적용하면 협업을 할 때 코드 상에 어떤 문제점이 발생해도 실수를 미연에 방지 할 수 있을 거라고 생각했다.

다만 너무 많은 규칙을 적용하면 기초 프로젝트라는 현재 상황과 맞지 않게 어떤 오류가 발생했는지 검토해보는 시간을 너무 많이 투자할 것이라고 생각했기 때문에, 최소한의 규칙만 적용해보았다.

이번엔 다음과 같은 규칙을 중심으로 ESLint 규칙을 적용했다.
|규칙 이름|	설명|
|---|---|
|`no-unused-vars: ["error", { varsIgnorePattern: "^[A-Z_]" }]`|	사용되지 않는 변수에 대해 오류를 발생시키되, 대문자 또는 밑줄(_)로 시작하는 변수는 예외 처리합니다. 보통 상수(예: PI, _DEBUG)는 사용하지 않아도 경고하지 않게 설정합니다.|
|`react-refresh/only-export-components: ["warn", { allowConstantExport: true }]`|	React Fast Refresh를 지원하기 위해, React 컴포넌트는 default 혹은 named export로만 내보내야 함을 권고합니다. 단, 상수 형태의 export는 허용됩니다.|
|`react-hooks/rules-of-hooks`|	React Hook은 함수형 컴포넌트나 custom Hook 내에서만 호출되어야 한다는 기본 규칙입니다. 위반 시 오류를 발생시킵니다.|
|`react-hooks/exhaustive-deps`|	useEffect, useCallback, useMemo 등에서 의존성 배열 누락을 감지해 경고를 발생시킵니다. 의도치 않은 사이드 이펙트를 방지합니다.|

### ✅ Husky + lintStaged
ESLint, Prettier 규칙을 더 정확하고 자동으로 지켜지게 만들기 위해 Husky와 lint Staged 조합을 사용했다.

아래와 같이 Git 커밋 전에 수정된 js, jsx, ts, tsx 파일 대상으로 자동으로 ESLint와 Prettier를 실행해 코드를 한번 더 정리하고 규칙에 맞게 관리할 수 있었다.
|설정 대상|	실행 명령|
|---|---|
|`**/*.{js,jsx,ts,tsx}`	|`eslint --fix, prettier --write`|


### ❓ Husky
Husky는 Git 커밋이나 푸시 등의 이벤트가 발생하기 전에 자동으로 특정 스크립트나 검사 로직을 실행할 수 있게 해주는 도구이다.
예를 들어 커밋 전에 수정 된 js, jsx, ts, tsx 파일에 대해 자동으로 ESLint나 Prettier 검사를 실행하여 문제가 있는 경우 commit 자체를 막는 등 일관된 코드 스타일과 품질을 유지하는데 매우 유용하다.

### ❓ Lint Staged
Lint-staged는 Git에 staged된, 즉 변경된 파일만 대상으로 린트(lint)나 포맷을 수행할 수 있게 해주는 도구이다.
Husky와 조합해서 사용하면, 변경된 파일만 대상으로 포맷을 수행할 수 있게 해줘서 코드 스타일 및 품질을 유지할 때 효율적이고 빠르게 적용할 수 있다.

## 💡 Alias 규칙 설정
@ 기호를 src 디렉토리로 매핑하여, 모든 경로 참조 시에 절대 경로로 참조할 수 있도록 규칙을 만들어보았다.
```js
resolve: {
  alias: {
    '@': path.resolve(__dirname, 'src'),
  },
}
```
이 Alias 규칙을 사용할 때는 다른 규칙을 사용할 때와 다르게 장/단점을 조금 명확하게 느꼈다.
### 장점
어떤 파일을 import할때 수동으로 작성할때는 굉장히 편한 것을 느꼈다.
예를들어 이미지를 import할 때 기존에는 많이 불편함을 느꼈는데, 폴더 컨벤션을 미리 지정해놓고 외워두니 상대경로 참조를 위해 ../로 거슬러 올라갈 필요없이 `@/assets/images/파일명`, `@/assets/icons/파일명` 를 통해 바로 접근할 수 있어서 편했다.

### 단점
vsc 에서 자동으로 import 구문을 작성해주는 경우(컴포넌트를 자동으로 import 해주는 경우 등)에 상대경로 참조로 입력해주면 ctrl+클릭으로 바로 해당 파일로 이동할 수 있었다.

하지만 절대경로로 입력해주는경우 컴파일 되면서 @가 src로 변환되어 해당 경로를 참조하는 방식이기 때문에 코드를 작성하는 단계에서는 ctrl+클릭으로 해당 파일로 이동이 불가능해서 코드를 작성할때 오히려 불편함을 겪었었다.

### 결론
아예 사용하지 않는 것은 오히려 불편할 것 같고,

이미지같이 자동으로 import가 안되는 경우에만 @ 매핑을 통한 절대경로 참조를 이용해주면 훨씬 편하게 작업이 가능할 것 같다.

