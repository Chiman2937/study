# 📝 기능 구현 - 텍스트에디터 (설계)

이 또한 설계 목표를 설정하고, 어떤 식으로 개발할 지 생각해보았다.

## 💡 구조 설계(기본 HTML 요소)

<img width="610" height="142" alt="image" src="https://github.com/user-attachments/assets/8445d280-c687-4618-b30e-2065b0fea527" />

- (1) 제목, 본문, 인용구를 선택가능
- (2) bold, italic, underline, strike 스타일을 자유롭게 지정 가능
- (3) Ordered List, Unordered List 선택가능
- (4) 텍스트 좌/우/가운데 정렬 지정 가능

## 💡 Tiptap의 기본구조

Tiptap은 bold, italic 같은 기본기능을 위한 starterkit이 존재한다.

```bash
npm install @tiptap/starter-kit
```

[[🔗 Tiptap StarterKit Guide]](https://tiptap.dev/docs/editor/extensions/functionality/starterkit#using-the-starterkit-extension)

<details>
  <summary><h4>✅ Tiptap 기본기능 예제</h4></summary>

아래와 같이 기본 예제를 제공하며, 스타일 적용을 위한 커맨드와 그 스타일이 적용되어있는지 확인할 수 있는 isActive 함수를 제공한다.
  
```tsx
import './styles.scss'

import { TextStyleKit } from '@tiptap/extension-text-style'
import type { Editor } from '@tiptap/react'
import { EditorContent, useEditor, useEditorState } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import React from 'react'

const extensions = [TextStyleKit, StarterKit]

function MenuBar({ editor }: { editor: Editor }) {
  // Read the current editor's state, and re-render the component when it changes
  const editorState = useEditorState({
    editor,
    selector: ctx => {
      return {
        isBold: ctx.editor.isActive('bold') ?? false,
        canBold: ctx.editor.can().chain().toggleBold().run() ?? false,
        isItalic: ctx.editor.isActive('italic') ?? false,
        canItalic: ctx.editor.can().chain().toggleItalic().run() ?? false,
        isStrike: ctx.editor.isActive('strike') ?? false,
        canStrike: ctx.editor.can().chain().toggleStrike().run() ?? false,
        isCode: ctx.editor.isActive('code') ?? false,
        canCode: ctx.editor.can().chain().toggleCode().run() ?? false,
        canClearMarks: ctx.editor.can().chain().unsetAllMarks().run() ?? false,
        isParagraph: ctx.editor.isActive('paragraph') ?? false,
        isHeading1: ctx.editor.isActive('heading', { level: 1 }) ?? false,
        isHeading2: ctx.editor.isActive('heading', { level: 2 }) ?? false,
        isHeading3: ctx.editor.isActive('heading', { level: 3 }) ?? false,
        isHeading4: ctx.editor.isActive('heading', { level: 4 }) ?? false,
        isHeading5: ctx.editor.isActive('heading', { level: 5 }) ?? false,
        isHeading6: ctx.editor.isActive('heading', { level: 6 }) ?? false,
        isBulletList: ctx.editor.isActive('bulletList') ?? false,
        isOrderedList: ctx.editor.isActive('orderedList') ?? false,
        isCodeBlock: ctx.editor.isActive('codeBlock') ?? false,
        isBlockquote: ctx.editor.isActive('blockquote') ?? false,
        canUndo: ctx.editor.can().chain().undo().run() ?? false,
        canRedo: ctx.editor.can().chain().redo().run() ?? false,
      }
    },
  })
```

</details>

## 🔍 트러블 슈팅

<h3>❓ 스타일 선택 시 툴바의 상태가 업데이트 되지않는 문제</h3>

#### ✅ 문제 현상

<img width="569" height="124" alt="image" src="https://github.com/user-attachments/assets/bdb4dd2c-943a-478b-886e-467698191643" />

> 예시: 가운데 정렬을 적용했으나, toolbar에 isActive(true) 상태가 적용되지 않음

#### ⚠️ 원인: Tiptap의 상태 관리 구조 방식

Tiptap은 useState같은 React 상태 관리 구조를 사용하지 않으며, ProseMirror 관리 방식을 사용한다.

그래서 어떤 스타일을 선택했을 때 Tiptap 내부의 상태는 변경하지만, React가 이것을 감지하지 못해 리렌더링이 되지 않는 것이다.

#### 💡 해결방법

Tiptap 에디터와 상태 동기화를 어떻게 할 수 있는지 찾아보았다.
| 이벤트 이름            | 발생 조건                                     | 용도                                                    | 예시                                     |
| ----------------- | ----------------------------------------- | ----------------------------------------------------- | -------------------------------------- |
| `selectionUpdate` | **커서 위치 또는 선택 영역(selection)이 바뀔 때**       | 현재 selection에 따라 툴바 버튼(active 상태 등)을 갱신할 때 사용         | `isActive('bold')` 상태 갱신               |
| `transaction`     | **문서 상태가 변경될 때 (mark, node, attr 등)**     | 스타일 적용(굵게, 정렬, 리스트 등) 후에도 툴바 상태를 정확히 반영               | `setTextAlign('center')` 실행 직후 상태 업데이트 |
| `update`          | **EditorState 전체가 바뀔 때** (transaction 포함) | 전체 동기화용, 대체로 `transaction`과 유사하지만 selection 관련 반응은 없음 | 문서 전체의 구조를 분석할 때                       |
| `focus`           | 에디터에 포커스가 들어올 때                           | 포커스 여부로 UI 변경 시 사용                                    | 툴바 활성화, border 강조 등                    |
| `blur`            | 에디터에서 포커스가 빠질 때                           | 포커스 여부로 UI 변경 시 사용                                    | 툴바 숨기기 등                               |
| `destroy`         | 에디터 인스턴스가 파괴될 때                           | 클린업 로직 실행                                             | socket 연결 해제 등                         |
| `create`          | 에디터가 초기화될 때                               | 에디터 초기 설정 완료 후 초기 상태 가져오기                             | 초기 값 세팅                                |


이 이벤트들 전부 적용하는 것은 낭비이기 때문에 텍스트 에디터가 언제 업데이트 되어야 하는지를 먼저 고민해보았다.

- 커서가 이동했을 때(해당 위치의 노드의 스타일을 업데이트 해줘야함)
- toolbar에서 스타일을 선택한 직후

따라서 selectionUpdate와 transaction 이벤트 두가지를 사용해서 강제 업데이트 구문을 적용하기로 했다.

```tsx
  const [, forceUpdate] = useReducer((x) => x + 1, 0);

  useEffect(() => {
    if (!editor) return;
    const handler = () => {
      forceUpdate();
    };

    editor.on('transaction', handler);
    editor.on('selectionUpdate',handler);
    return () => {
      editor.off('transaction', handler);
      editor.off('selectionUpdate',handler);
    };
  }, [editor]);
```

이를 통해 화면이 강제 리렌더링 되도록 구현했다.
