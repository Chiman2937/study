# 📝 기능 구현 - toast 컴포넌트(설계)

뚜렷한 설계 목표를 설정하고, 어떤식으로 개발할 지 구조설계를 먼저 진행 해보았다.

## 💡 구조 설계(최종 결과물)
<img width="2528" height="1344" alt="image" src="https://github.com/user-attachments/assets/2d3deb46-c654-4021-9e6a-b037b142d507" />

1. cy-toast 는 <ToastRender/> 와 toast.ts를 제공한다.
2. Toast를 사용할 컴포넌트에 <ToastRender/>를 렌더링 시킨다.
3. toast.ts 의 함수 toast.run 함수를 호출하여 toast 컴포넌트를 전달하며 state를 업데이트 한다.
5. state가 변경됨에 따라 화면에 toast 컴포넌트가 렌더링 된다.

## 🔍 트러블 슈팅

<details>

  <summary><h3>❓ npm 패키지에 Tailwind CSS를 적용했을 때 스타일이 반영되지 않는 문제 정리</h3></summary>

이번에는 Next.js로 프로젝트를 진행하면서 tailwind를 적용했었고, npm 패키지를 만들때도 tailwind css를 적용해서 만들었다.
tailwind css를 적용했던 이유는 npm 패키지 내부에서 별도의 css파일을 만들고 싶지 않았고, tailwind가 사용하기 편했기 때문이다.

<br></br>

#### ✅ 문제 현상
이번에는 Next.js로 프로젝트를 진행하면서 tailwind를 적용했었고,
npm 패키지를 만들때도 tailwind css를 적용해서 만들었다.
그런데 이를 다른 프로젝트에서 사용했을 때 컴포넌트 구조나 로직은 정상적으로 동작하지만, Tailwind 클래스로 지정한 UI 스타일이 정상적으로 반영되지 않는 문제가 있었다.

<br></br>

#### ⚠️ 원인: Tailwind JIT 방식의 특성
Tailwind CSS는 기본적으로 JIT(Just-In-Time) 방식으로 동작하며, 실제 사용된 클래스만을 CSS로 빌드한다.

여기서 중요한 점은 “실제로 사용된” 이라는 판단 기준이 tailwind.config.js의 content 경로에 포함된 파일 내에서 문자열로 탐지된 클래스만 의미한다는 점이다.

```ts
//tailwind.config.ts
const config: Config = {
  content: ['./src/**/*.{js,ts,jsx,tsx}', './styles/**/*.{css,scss}'],
  ...
}
```

<br></br>

📦 npm 패키지의 특수성
- npm 패키지로 만들어 배포된 컴포넌트는 결국 다른 프로젝트의 node_modules/ 내부에 위치
- 대부분의 Tailwind 설정에서 node_modules/는 content 경로에 포함되어 있지 않음
- 그래서 패키지 내부의 코드에서 아무리 bg-blue-500 같은 기본 클래스를 써도, Tailwind는 그 클래스가 실제로 사용되었다고 인식하지 못하고 제거함

결과적으로, 기본 클래스라도 content 경로에 없으면 빌드 결과물에 포함되지 않는다.

<br></br>

#### 💡 해결방법

css파일을 별도로 만들지 않으며 tailwind css를 사용하지 않는 방식을 위해 inline으로 스타일을 설정해주었다.

```tsx
return createPortal(
    <div
      style={{
        position: 'absolute',
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        pointerEvents: 'none',
      }}
    >
  ...
```

<br></br>

---

</details>

<details>

  <summary><h3>❓ toast함수 호출 시 ToastRender의 상태 업데이트 방법에 대한 고민</h3></summary>

이 구조를 구현할 때 가장 어려움을 겪었던 부분이었다.

ToastRender는 Provider가 아니고, toast.ts 파일에 상태를 props로 전달해주는 형태가 아니기 때문에 setState를 사용할 방법이 없었다.

그래서 ToastRender가 mount 될 때 setState 함수를 toast.ts의 함수에 전달해주고, 이 함수가 전역에 보관되는 방식을 도전해 보았다.

<br></br>

#### ✔️ ToastRender가 실행될 때 구독 상태 만들기

ToastRender가 mount 될 때 toast의 connect라는 함수를 실행시켜 구독상태를 만드는 방법을 생각해보았다.
```tsx
export const ToastRender = () => {
  const [mounted, setMounted] = useState(false);
  const [toasts, setToasts] = useState<Toast[]>([]);

  useEffect(() => {
    setMounted(true);
    const disconnect = toast._connect(setToasts); // 구독상태를 만들며, 반환함수로 구독해제함수를 받아오기
    return () => disconnect(); // unmount 될 때 구독 해제
  }, []);
  
if (!mounted) return null;
return ...
```

```ts
//toast.ts

let toasts: Toast[] = [];
let listeners: ((nodes: Toast[]) => void)[] = [];

export const toast = {
  ...
  _connect(setToasts: (nodes: Toast[]) => void) {
    listeners.push(setToasts); // 구독 리스트에 등록
    setToasts(toasts); // 현재 Toast 상태를 바로 반영
    return () => { // 구독 해제 함수 반환
      listeners = listeners.filter((l) => l !== setToasts);
    };
  },
}
```

<br></br>

💡 toasts, listeners 전역변수를 생성

- toasts: ToastRender 컴포넌트의 상태에 전달할 Toast정보를 미리 보관하기 위한 전역 변수 
- listeners: setState함수를 담고있는 전역 배열. 이를 통해 구독상태를 만들어준다.

   - setToasts 함수를 파라미터로 받는데, 이 함수의 type은 `(nodes: Toast[]) => void` 이다.

<br></br>

💡 listeners를 setState함수의 배열로 만들기
- ToastRender가 최상위에서 한번만 렌더링 된다면 상관없지만, 그렇지 않다면 ToastRender별로 동일한 state가 관리되게 만들어야한다.

> `ToastRender1` → `setToasts1`
> 
> `ToastRender2` → `setToasts2`
```ts
listeners = [setToasts1, setToasts2]
```

<br></br>

💡 구독 해제 함수 반환
- ToastRender가 unmount 될 때 메모리 초기화를 위해 disConnect 함수를 반환한다.

<br></br>

💡 `ToastRender.tsx`의 상태 업데이트 하기

- setState의 배열인 listeners를 순회하며 실행해 ToastRender의 상태가 업데이트 되게 만든다.

```tsx
const renderToasts = () => {
  listeners.forEach((l) => l(toasts));
};
```

</details>
