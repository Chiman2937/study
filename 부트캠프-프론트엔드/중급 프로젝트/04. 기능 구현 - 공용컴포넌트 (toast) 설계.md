# 📝 기능 구현 - toast 컴포넌트(설계)

뚜렷한 설계 목표를 설정하고, 어떤식으로 개발할 지 구조설계를 먼저 진행 해보았다.

## 💡 구조 설계(최종 결과물)
<img width="2528" height="1344" alt="image" src="https://github.com/user-attachments/assets/2d3deb46-c654-4021-9e6a-b037b142d507" />

1. cy-toast 는 <ToastRender/> 와 toast.ts를 제공한다.
2. Toast를 사용할 컴포넌트에 <ToastRender/>를 렌더링 시킨다.
3. toast.ts 의 함수 toast.run 함수를 호출하여 toast 컴포넌트를 전달하며 state를 업데이트 한다.
5. state가 변경됨에 따라 화면에 toast 컴포넌트가 렌더링 된다.

## 🔍 트러블 슈팅

<details>

  <summary><h3>❓ npm 패키지에 Tailwind CSS를 적용했을 때 스타일이 반영되지 않는 문제 정리</h3></summary>

이번에는 Next.js로 프로젝트를 진행하면서 tailwind를 적용했었고, npm 패키지를 만들때도 tailwind css를 적용해서 만들었다.
tailwind css를 적용했던 이유는 npm 패키지 내부에서 별도의 css파일을 만들고 싶지 않았고, tailwind가 사용하기 편했기 때문이다.

<br></br>

#### ✅ 문제 현상
이번에는 Next.js로 프로젝트를 진행하면서 tailwind를 적용했었고,
npm 패키지를 만들때도 tailwind css를 적용해서 만들었다.
그런데 이를 다른 프로젝트에서 사용했을 때 컴포넌트 구조나 로직은 정상적으로 동작하지만, Tailwind 클래스로 지정한 UI 스타일이 정상적으로 반영되지 않는 문제가 있었다.

<br></br>

#### ⚠️ 원인: Tailwind JIT 방식의 특성
Tailwind CSS는 기본적으로 JIT(Just-In-Time) 방식으로 동작하며, 실제 사용된 클래스만을 CSS로 빌드한다.

여기서 중요한 점은 “실제로 사용된” 이라는 판단 기준이 tailwind.config.js의 content 경로에 포함된 파일 내에서 문자열로 탐지된 클래스만 의미한다는 점이다.

```ts
//tailwind.config.ts
const config: Config = {
  content: ['./src/**/*.{js,ts,jsx,tsx}', './styles/**/*.{css,scss}'],
  ...
}
```

<br></br>

📦 npm 패키지의 특수성
- npm 패키지로 만들어 배포된 컴포넌트는 결국 다른 프로젝트의 node_modules/ 내부에 위치
- 대부분의 Tailwind 설정에서 node_modules/는 content 경로에 포함되어 있지 않음
- 그래서 패키지 내부의 코드에서 아무리 bg-blue-500 같은 기본 클래스를 써도, Tailwind는 그 클래스가 실제로 사용되었다고 인식하지 못하고 제거함

결과적으로, 기본 클래스라도 content 경로에 없으면 빌드 결과물에 포함되지 않는다.

<br></br>

#### 💡 해결방법

css파일을 별도로 만들지 않으며 tailwind css를 사용하지 않는 방식을 위해 inline으로 스타일을 설정해주었다.

```tsx
return createPortal(
    <div
      style={{
        position: 'absolute',
        width: '100%',
        height: '100%',
        top: 0,
        left: 0,
        pointerEvents: 'none',
      }}
    >
  ...
```

<br></br>

---

</details>
