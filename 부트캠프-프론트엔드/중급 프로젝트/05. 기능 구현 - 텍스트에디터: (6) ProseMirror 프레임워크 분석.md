# 📝 ProseMirror 프레임워크 분석

Tiptap은 ProseMirror 프레임워크 기반으로 동작하는 라이브러리로, Tiptap의 상태관리는 전적으로 ProseMirror 프레임워크에 의존한다.

따라서 Tiptap의 동작을 이해하려면 ProseMirror 프레임워크가 무엇이고, 어떻게 동작하는지를 이해하여야 한다.

<br></br>

## 🔍 ProseMirror란?

ProseMirror는 에디터의 “상태”, “동작”, “렌더링”을 통합적으로 설계·조작·관리할 수 있도록 설계된 웹 기반 리치 텍스트 에디터 아키텍처이다.

즉, 문서 상태를 구조화하고, 그 상태를 조작하고, 최종적으로 DOM에 렌더링하는 전체 흐름을 하나의 프레임워크로 제공하는 통합 시스템이다.

### ❓ **소프트웨어 아키텍처(Software Architecture)** 란?

> “시스템을 구성하는 핵심 요소들과, 그들 간의 관계, 그리고 이들이 어떻게 상호작용하는지를 정의한 구조적 설계”이다.

<br></br>

## 💡 ProseMirror의 핵심 목표
ProseMirror는 다음과 같은 목표를 달성하기 위해 설계되었다.
- 문서 상태를 구조적으로 정의
- 트랜잭션 기반으로 상태를 조작
- 정확하고 예측 가능한 방식으로 뷰를 렌더링
- 실시간 협업, 히스토리, 플러그인 확장 등을 지원

<br></br>

## 📌 ProseMirror의 구성 요소와 동작 순서

| 구성 요소          | 설명                                                                         |
| -------------- | -------------------------------------------------------------------------- |
| `Schema`       | 문서 구조를 정의 (어떤 노드/마크가 존재하는지, 어떤 속성을 가지는지 등)                                 |
| `Node`, `Mark` | 실제 문서의 구성 요소 (문단, 이미지, 링크 등)                                               |
| `EditorState`  | 현재 문서 상태 + 커서 위치 + 플러그인 상태 등 전체 에디터 상태                                     |
| `Transaction`  | 상태를 변경하는 명령 (ex. 텍스트 삽입, 노드 삭제 등)                                          |
| `EditorView`   | 상태를 실제 DOM으로 렌더링하고 사용자 입력을 감지하는 렌더링 계층                                     |
| `Plugin`       | 에디터에 기능을 추가하거나 상태에 반응하는 확장 시스템 (예: 히스토리, 키보드 단축키, collaborative editing 등) |

```
사용자 입력 / 명령어
      ↓
Transaction 생성
      ↓
새로운 EditorState 생성
      ↓
EditorView가 DOM 업데이트
```



## 🔧 ProseMirror 구성요소 파헤쳐보기

<details>
<summary><h3>✔️ schema</h3></summary>

schema는 ProseMirror에서 문서의 구조를 정의하는 핵심 구성 요소로, 어떤 `Node`와 `Mark`가 들어갈 수 있는지 정의한다.

---

</details>

<details>
<summary><h3>✔️ Node와 Mark</h3></summary>

ProseMirror에서 `Node`와 `Mark`는 둘 다 HTML의 노드 구조 개념에서 출발했지만, 문서 상태를 더 정밀하게 표현하기 위해 의미론적으로 분리된 개념이다.

| 구분       | 종류 (예시)                                                                           | 대응되는 HTML 요소                                                         | 설명                                                                        |
| -------- | --------------------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **Node** | `paragraph`, `heading`, `blockquote`, `image`, `codeBlock`, `listItem`, `table` 등 | `<p>`, `<h1>`, `<blockquote>`, `<img>`, `<pre>`, `<li>`, `<table>` 등 | 문서의 \*\*구조(Structure)\*\*를 형성하는 요소. 블록 또는 인라인 노드로 나뉘며 계층적 트리를 구성          |
| **Mark** | `bold`, `italic`, `underline`, `strike`, `link`, `code` 등                         | `<strong>`, `<em>`, `<u>`, `<s>`, `<a>`, `<code>` 등                  | 텍스트에 \*\*스타일이나 의미(Semantic Annotation)\*\*를 부여하는 요소. 노드 내부의 텍스트에 겹쳐 적용 가능 |

이런식으로 구조와 스타일을 분리하면 상태 저장, 수정, 추적이 훨씬 깔끔해진다는 장점이있다.

#### ✅ 예제

예를 들어 `굵고 기울어진 링크` 텍스트를 HTML로 표현하면 다음과 같이 중첩된 태그 구조를 갖는다:

```html
<a href="..."><strong><em>링크요소</em></strong></a>
```

하지만 ProseMirror에서는 이러한 중첩 스타일을 구조적 트리로 표현하는 대신, 하나의 text 노드에 여러 mark를 배열 형태로 적용하여 표현한다.

이 방식은 중첩 순서와 상관없이 쉽게 스타일을 추가/제거/검사할 수 있게 한다.

```json
{
  "type": "text",
  "text": "링크요소",
  "marks": [
    { "type": "bold" },
    { "type": "italic" },
    { "type": "link", "attrs": { "href": "https://..." } }
  ]
}
```

---

</details>

<details>

<summary><h3>✔️ EditorState</h3></summary>

- EditorState는 ProseMirror 에디터의 전체 상태를 표현하는 인스턴스 불변 객체이다.

<br></br>

#### ❓ EditorState가 불변 객체인 이유

| 이유                    | 설명                                                                |
| --------------------- | ----------------------------------------------------------------- |
| **1. 명확한 히스토리 관리**    | 상태를 직접 변경하지 않고 새로운 상태를 생성함으로써 이전 상태를 안전하게 저장 가능 (Undo/Redo 구현 용이) |
| **2. 예측 가능한 상태 흐름**   | 모든 변경이 `Transaction`을 통해 이뤄지므로 상태 변화가 추적 가능하고 side-effect가 없음     |
| **3. 협업(동기화)에 유리**    | 변경 이력을 구체적인 트랜잭션 단위로 분리해 충돌 감지와 병합이 쉬움 (Yjs 등 CRDT 연동에 최적)        |
| **4. 버그 감소 / 디버깅 용이** | 이전 상태를 그대로 보존할 수 있어 디버깅 시 비교/되돌리기 쉬움                              |
| **5. 구조 공유 최적화 가능**   | 변경되지 않은 부분은 공유(reuse)할 수 있어 성능 저하 없이 안전한 상태 분기 가능                 |

EditorState는 매번 상태 객체를 새로 생성하면서 객체가 계속 늘어날텐데, 성능 상 문제는 없을까?

<br></br>

#### ❓ 구조 공유(Structural Sharing) 방식
EditorState는 **"변경된 부분만 새로 생성하고, 나머지 구조는 이전 상태와 메모리 참조를 공유"** 하는 방식으로 최적화를 진행한다.

이를 통해 메모리 누수 없이 안정적인 상태관리가 가능하다.

#### 🔍 예제
<details>
      <summary>1단계(초기 문서 상태)</summary>

텍스트 에디터 내용
```
Hello
```
```js
state1.doc = {
  type: "doc",
  content: [
    {
      type: "paragraph",   // (P1)
      content: [
        { type: "text", text: "Hello" }  // (T1)
      ]
    }
  ]
}
```
</details>

<details>
      <summary>2단계(텍스트 추가)</summary>

텍스트 에디터 내용
```
Hello World
```
- 변경된 부분: text 노드 (T2)
- 공유되는 부분: paragraph 노드 (P1)
```js
state2.doc = {
  type: "doc",
  content: [
    {
      type: "paragraph",   // (P1) ← 공유됨
      content: [
        { type: "text", text: "Hello world" }  // (T2) ← 새로 생성
      ]
    }
  ]
}

```

</details>

<details>
      <summary>3단계(문단 추가)</summary>

텍스트 에디터 내용
```
Hello World
New paragraph
```
- 변경된 부분: 새로운 paragraph 노드 (P2), 새로운 text 노드 (T3)
- 공유되는 부분: 기존 paragraph (P1), 기존 text (T2)
```js
state3.doc = {
  type: "doc",
  content: [
    {
      type: "paragraph",   // (P1) ← 그대로
      content: [
        { type: "text", text: "Hello world" }  // (T2) ← 그대로
      ]
    },
    {
      type: "paragraph",   // (P2) ← 새로 생성
      content: [
        { type: "text", text: "New paragraph" } // (T3) ← 새로 생성
      ]
    }
  ]
}
```

</details>

<details>
      <summary>4단계(bold 마크 추가)</summary>

텍스트 에디터 내용
```
Hello World
**New paragraph** (bold)
```
- 변경된 부분: text 노드 (T4) ← 마크가 추가되어 새로 생성됨
- 공유되는 부분: P1, T2, P2 그대로 사용됨
```js
state4.doc = {
  type: "doc",
  content: [
    {
      type: "paragraph",   // (P1)
      content: [
        { type: "text", text: "Hello world" }  // (T2)
      ]
    },
    {
      type: "paragraph",   // (P2)
      content: [
        {
          type: "text",
          text: "New paragraph",
          marks: [{ type: "bold" }]  // (T4) ← 새로 생성
        }
      ]
    }
  ]
}

```

</details>

🧩 예제 요약

| 상태 변화             | 새로 생성된 객체 | 공유된 객체     |
| ----------------- | --------- | ---------- |
| `state1 → state2` | T2        | P1         |
| `state2 → state3` | P2, T3    | P1, T2     |
| `state3 → state4` | T4        | P1, T2, P2 |


<br></br>



#### ❓ EditorState의 구성요소

EditorState는 다음과 같은 핵심 속성들을 포함한다.

| 속성            | 설명                                                                                   |
| ------------- | ------------------------------------------------------------------------------------ |
| `doc`         | 문서 트리 구조. `Schema`에 따라 정의된 `Node` 객체의 루트 (`type: "doc"`).                            |
| `selection`   | 현재 커서 위치 또는 텍스트 선택 범위. `TextSelection`, `NodeSelection`, `AllSelection` 등의 하위 타입 존재. |
| `schema`      | 해당 상태가 따르는 스키마 구조. 어떤 노드/마크가 존재 가능한지를 정의.                                            |
| `plugins`     | 이 상태에 포함된 플러그인 목록. 각 플러그인은 자체적인 상태를 가질 수 있음.                                         |
| `storedMarks` | 입력 중인 텍스트에 적용할 마크(스타일). 현재 입력 위치에서 bold 등 적용된 상태를 기억함.                               |

---

</details>

<details>

<summary><h3>✔️ Transaction</h3></summary>

ProseMirror의 `Transaction`은 사용자의 편집 행동이나 프로그래밍 명렁을 통해 문서 상태를 예측 가능하게 변경하기 위한 변화 기록 객체이다.

Transaction은 기존 상태를 바꾸는게 아니라 새로운 상태를 생성하는데 사용된다.

#### ❓ Transaction 구성 요소
| 속성                 | 설명                                                     |
| ------------------ | ------------------------------------------------------ |
| `steps`            | 문서 변경의 단위 목록. 예: 텍스트 삽입, 노드 삭제 등 (`Step` 객체로 구성됨)      |
| `selection`        | 이 트랜잭션이 적용된 후의 커서 위치나 선택 범위                            |
| `storedMarks`      | 다음 삽입될 텍스트에 적용할 마크들 (예: bold가 눌려있을 때 새로운 텍스트에 bold 적용) |
| `meta`             | 트랜잭션에 첨부된 사용자 정의 메타데이터 (플러그인에서 사용)                     |
| `docChanged`       | 이 트랜잭션이 문서에 실제로 변경을 일으켰는지 여부                           |
| `before` / `after` | 트랜잭션이 적용되기 전/후의 문서 상태. 디버깅 및 히스토리 관리에 사용됨              |


#### 🔍 Transaction 생성 예시

```ts
const { tr } = editor.state;

// 예: 텍스트 삽입
const newTr = tr.insertText("안녕하세요", 5);

// 예: 선택 범위 변경
newTr.setSelection(TextSelection.create(newTr.doc, 10, 15));

// 예: 마크 설정
newTr.addStoredMark(schema.marks.bold.create());

// 트랜잭션 적용
editor.view.dispatch(newTr);
```
예제를 보면 알 수 있지만, `Transaction`은 새로운 상태를 생성하기 위한 "변화의 명세서(동작들의 집합)"이고,

`EditorView`는 이 Transaction을 수신하고 실행하여 실제 상태를 갱신하고 화면을 업데이트하는 주체이다.

---

</details>

<details>

<summary><h3>✔️ EditorView</h3></summary>

EditorView는 EditorState를 기반으로 실제 화면을 렌더링하고, 사용자의 입력을 감지하여 Transaction을 실행(dispatch) 하는 역할을 한다.

#### ❓ EditorView의 역할
| 역할           | 설명                                                    |
| ------------ | ----------------------------------------------------- |
| 🔁 상태 렌더링    | `EditorState`를 기반으로 문서를 **DOM으로 렌더링**함 (커서 포함)        |
| 🧠 사용자 입력 감지 | 키보드, 마우스, IME 입력 등을 감지하여 **트랜잭션을 생성**하거나 **플러그인에 위임** |
| 📤 트랜잭션 디스패치 | 외부나 내부에서 들어온 `Transaction`을 **적용**하고 **새로운 상태로 갱신**함  |
| 🎯 선택 상태 유지  | 커서 및 선택 영역을 정확히 반영하고 DOM selection과 동기화함              |
| 🔌 플러그인 반영   | 플러그인의 props를 통해 입력 처리, 뷰 커스터마이징, 이벤트 처리 가능            |

<br></br>

#### ❓ EditorView 사용 예시
```ts
// 1. Transaction 생성
const tr = editorView.state.tr.insertText("Hello", 5);

// 2. Transaction 디스패치 (적용)
editorView.dispatch(tr);
```

---

</details>
