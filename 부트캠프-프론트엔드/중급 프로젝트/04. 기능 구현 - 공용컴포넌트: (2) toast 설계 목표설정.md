# 📝 기능 구현 - toast 컴포넌트

공용컴포넌트 중 Toast 컴포넌트 개발을 담당했다.

라이브러리를 사용하여 개발할까 생각도 했지만

`컴포넌트의 재사용성 높이기, 상태관리 구조를 최적화하기 위한 고민 해보기` 라는 목표에 도전해보기 위해 직접 컴포넌트를 만들어보기로 했다.

<br></br>
---

## 💡 기초 프로젝트 때는?
기초 프로젝트 때도 Toast 컴포넌트를 개발했었다.

<details>
  <summary>🔍 기초프로젝트때 개발한 Toast컴포넌트</summary>


### ✔️ ToastProvider 구현
```tsx
export const ToastProvider = ({ children }) => {
  const [toasts, setToasts] = useState([]);

  const closeToast = (id) => ...
  const showToast = ({ type, message, timer }) => ...
  ...
  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      {toasts.length > 0 &&
        createPortal(
          <div className={styles['toast-wrapper']}>
            {toasts.map((t) => (
              <Toast
                key={t.id}
                message={t.message}
                type={t.type}
                timer={t.timer}
                onClose={() => closeToast(t.id)}
              />
            ))}
          </div>,
          document.getElementById('toast-root'),
        )}
    </ToastContext.Provider>
  );

```

### ✔️ 가장 상위 컴포넌트(main.tsx)에서 Provider로 감싸준다.
```tsx
createRoot(document.getElementById('root')).render(
  <StrictMode>
    <ToastProvider>
      <App />
    </ToastProvider>
  </StrictMode>,
);

```

### ✔️ 페이지 컴포넌트에서는 showToast 함수를 통해 Toast를 호출한다.
```tsx
const PageComponent = () => {
  const { showToast } = useToast();

  const handleToastClick = () => {
    showToast?.({
      type: 'fail',
      message: '롤링페이퍼 생성 요청에 실패했습니다.',
      timer: 2000,
    });
  }
  ...
}
```

#### 👍 잘했던 점
- 페이지 컴포넌트에서 토스트를 호출할 때 상태관리를 따로 해주지 않아도 되도록 만들었다.
- Provider를 최상위에서 한번만 감싸주면 어떤 페이지에서든 호출할 수 있도록 만들었다.

#### 🔥 아쉬웠던 점
- 렌더링 되는 컴포넌트가 고정이 되어있고 message나 type을 따로 넘겨주는 형태여서 커스터마이징이 불가능했다.
- 사용하고자 하는 페이지의 상위 컴포넌트에서 Provider로 감싸줘야 사용이 가능해서 역할이 명확히 구분되지 않았다.

  
</details>

<br></br>
---

## 💡 구현 목표

### 🔍 컴포넌트 재사용성 높이기

<details>
  <summary><h4>🧩 1. 현재 프로젝트 말고도 외부 프로젝트에서도 편하게 사용할 수 있도록 만들기</h4></summary>
  
  - Provider와 커스텀훅으로 공용컴포넌트를 만들었을 때 추가로 아쉬웠던 점은, 다른 프로젝트에서 사용하려면 Provider와 커스텀훅을 직접 복사한 후 사용해야 한다는 점이었다.
  - 라이브러리를 사용할 경우 npm install로 설치만 하면 즉시 사용할 수 있는 점을 떠올렸고 직접 npm 패키지를 만들어보기로 하였다.

  ---
</details>

<details>
  <summary><h4>🧩 2. 각 페이지에서는 toast show/close 상태를 관리하지 않기</h4></summary>

  - 각 페이지에서 toast를 위한 상태 관리를 하는것은 역할 분리가 명확하지 않다
  - 또한 공통적인 로직이기 때문에 하나로 묶을 수 있다

  ---
</details>

<details>

  <summary><h4>🧩 3. 상태를 관리하는 컴포넌트와 toast 호출 함수를 같은 페이지에서 호출할 수 있도록 만들기</h4></summary>

  - Provider와 커스텀훅을 사용할 경우, 실제 사용하고자하는 페이지의 `상위 컴포넌트`에 Provider를 감싸줘야한다는 문제가 있다.
  
  ```tsx
  const PageComponent = () => {
    const { showToast } = useToast();
    const handleToastClick = () => {
      showToast.({...})
    }
  }
  ```
  
  ```tsx
  const App = () => {
    <ToastProvider>
      <PageComponent />
    </ToastProvider>
  }
  ```
  이것은 로직이 분산되어있는것이라고 생각했기 때문에, 아래와 같이 상태를 관리하는 컴포넌트와 toast 호출함수를 같은 페이지에서 관리할 수 있도록 만들고자 했다.
  ```tsx
  const PageComponent = () => {
    const handleToastClick = () => {
      toast.run(...);
    }
    return (
      <ToastRender />
      ...
    )
  }
  ```

  ---

</details>

<br></br>
---

### 🔍 Headless UI 적용하기

<details>
  <summary><h4>🧩 1. 어떤 형태의 컴포넌트이든 자유롭게 적용 가능하도록 만들기</h4></summary>

  기초프로젝트에서 만들었던 Toast 컴포넌트는 message와 type을 전달해주는 방식으로, 커스터마이징이 불가능한 방식이었다.

  ```tsx
  const handleToastClick = () => {
    showToast?.({
      type: 'fail',
      message: '롤링페이퍼 생성 요청에 실패했습니다.',
      timer: 2000,
    });
  }
  ```

  그래서 이번에는 완벽한 Headless UI를 적용해 높은 자유도를 보장할 수 있도록 만들고자 했다.

  ```tsx
  const PageComponent = () => {
    const handleToastClick = () => {
      toast.run(<Toast />);
    }
    ...
  }
  ```
  ---
</details>

<br></br>
---

## 💡 구현 목표 요약
<img width="786" height="336" alt="image" src="https://github.com/user-attachments/assets/b3303898-3758-4f01-8daa-9a62fcf0fa35" />
